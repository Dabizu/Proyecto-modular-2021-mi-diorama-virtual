<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link type="text/css" rel="stylesheet" href="css/main.css">
	<link type="text/css" rel="stylesheet" href="css/emergente.css">
	<link href="https://fonts.googleapis.com/css?family=Montserrat:300,400,600|Open+Sans" rel="stylesheet"> 
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css">

	<link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400&amp;display=swap'>
	<link rel='stylesheet' href='https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css'>
	<script src="https://unpkg.com/vue@2/dist/vue.js"></script>
    <title>juego de aves</title>
	<style>
		#blocker {
			position: absolute;
			width: 20%;
			height: 20%;
			background-color: rgba(0,0,0,0.5);
			top: 50%;
			left: 0%;
		}

		#instructions {
			

			display: flex;
			flex-direction: column;
			justify-content: center;
			align-items: center;

			text-align: center;
			font-size: 14px;
			cursor: pointer;
		}
	</style>
</head>
<body>
	<div id="selection"></div>

	<div id="d1"></div>
	<div id="d2"></div>
	<div id="d3"></div>
	<div id="d4"></div>
	<div id="d5"></div>
	<div id="d6"></div>
	<div id="d7"></div>
	<div id="d8"></div>

	<div id="d9"></div>
	<div id="d10"></div>
	<div id="d11"></div>
	<div id="d12"></div>
	<div id="d13"></div>
	<div id="d14"></div>
	<div id="d15"></div>
	<div id="d16"></div>

	<div id="d17"></div>
	<div id="d18"></div>
	<div id="d19"></div>
	<div id="d20"></div>
	<div id="d21"></div>
	<div id="d22"></div>
	<div id="d23"></div>
	<div id="d24"></div>

	<div id="d25"></div>
	<div id="d26"></div>
	<div id="d27"></div>
	<div id="d28"></div>
	<div id="d29"></div>
	<div id="d30"></div>
	<div id="d31"></div>
	<div id="d32"></div>

	<div class="overlay" id="overlay">
        <div class="popup" id="popup" style="background-color: rgba(187, 179, 179, 0.5)">
            <a href="#" onclick="cerrar()" class="btn-cerrar-popup"><i class="fas fa-times"></i></a>
            <h1 id="nombre"></h1>
            <br>
            <button type="button" class="btn btn-outline-dark" onclick="cerrar()">siguiente</button>
        </div>
    </div>
	<div id="contenedorObjetos"></div>
    <script type="module" src="./scenaparque.js"></script>
	<script>
		function cerrar() {
			overlay.classList.remove('active');
			popup.classList.remove('active');
		}
	</script>
</body>
</html>



<!--
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - interactive cubes</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="css/main.css">
		<style>
			#d1,#d2,#d3,#d4{
				position: absolute;
				background-color: cyan;
				width: 60px;
				height: 60px;
				-moz-border-radius: 50%;
				-webkit-border-radius: 50%;
				border-radius: 50%;
				
			}
			#d5,#d6,#d7,#d8{
				position: absolute;
				background-color: cyan;
				width: 60px;
				height: 60px;
				-moz-border-radius: 50%;
				-webkit-border-radius: 50%;
				border-radius: 50%;
			}
			#contenedorObjetos{
				position: absolute;
				width: 200px;
				height: 200px;
				background-color: dodgerblue;
			}
			#dato{
				width: 80px;
				height: 40px;
				background-color:azure;
				margin: 3px;
			}
			#contenedorObjetos{
				overflow-y: scroll;
			}
		</style>
	</head>
	<body>
		<div id="selection">
			<div></div>
		</div>

		<div id="d1"></div>
		<div id="d2"></div>
		<div id="d3"></div>
		<div id="d4"></div>
		<div id="d5"></div>
		<div id="d6"></div>
		<div id="d7"></div>
		<div id="d8"></div>
		
		<div id="contenedorObjetos"></div>
		<script type="module">

			//import * as THREE from './build/three.module.js';
			import {scene, THREE} from './globales.js';
			//import Stats from './jsm/libs/stats.module.js';
			import * as GeometryUtils from './jsm/utils/GeometryUtils.js';
			import { CSS2DRenderer, CSS2DObject } from './jsm/renderers/CSS2DRenderer.js';
			import { FBXLoader } from './jsm/loaders/FBXLoader.js';

			let container;//let stats;
			let camera, raycaster, raycaster2, raycaster3, raycaster4, renderer;
			let raycaster5, raycaster6, raycaster7, raycaster8;

			let INTERSECTED, INTERSECTED2, INTERSECTED3, INTERSECTED4;
			let INTERSECTED5, INTERSECTED6, INTERSECTED7, INTERSECTED8;
			let theta = 0;

			const pointer = new THREE.Vector2();
			const pointer2 = new THREE.Vector2();
			const pointer3 = new THREE.Vector2();
			const pointer4 = new THREE.Vector2();

			const pointer5 = new THREE.Vector2();
			const pointer6 = new THREE.Vector2();
			const pointer7 = new THREE.Vector2();
			const pointer8 = new THREE.Vector2();
			
			const radius = 100;
/*
			//const punto=new THREE.Vector2();
			const dpr=window.devicePixelRatio;
			const textureSize=128*dpr;
			let texture;
			let sprite;*/

			var arreglo=new Array();
			var contador=0;
			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );

				//scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xf0f0f0 );

				const light = new THREE.DirectionalLight( 0xffffff, 1 );
				light.position.set( 1, 1, 1 ).normalize();
				scene.add( light );

				const geometry = new THREE.BoxGeometry( 20, 20, 20 );

				for ( let i = 0; i < 10; i ++ ) {

					const object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );

					object.position.x = Math.random() * 800 - 400;
					object.position.y = Math.random() * 800 - 400;
					object.position.z = Math.random() * 800 - 400;

					object.rotation.x = Math.random() * 2 * Math.PI;
					object.rotation.y = Math.random() * 2 * Math.PI;
					object.rotation.z = Math.random() * 2 * Math.PI;

					object.scale.x = Math.random() + 0.5;
					object.scale.y = Math.random() + 0.5;
					object.scale.z = Math.random() + 0.5;

					//le asignamos un nombre
					object.name="cubo"+i;

					scene.add( object );

				}
				

				raycaster = new THREE.Raycaster();
				raycaster2 = new THREE.Raycaster();
				raycaster3 = new THREE.Raycaster();
				raycaster4 = new THREE.Raycaster();

				raycaster5 = new THREE.Raycaster();
				raycaster6 = new THREE.Raycaster();
				raycaster7 = new THREE.Raycaster();
				raycaster8 = new THREE.Raycaster();

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				/*
				stats = new Stats();
				container.appendChild( stats.dom );*/

				//document.addEventListener( 'mousemove', onPointerMove );

				//

				window.addEventListener( 'resize', onWindowResize );


				/*
				//desde aqui inicia la modificacion
				//texture = new THREE.FramebufferTexture( textureSize, textureSize, THREE.RGBFormat );
				texture= new THREE.WebGLRenderTarget( textureSize, textureSize, THREE.RGBFormat);
				texture.minFilter = THREE.NearestFilter;
				texture.magFilter = THREE.NearestFilter;

				const spriteMaterial = new THREE.SpriteMaterial( { map: texture } );
				sprite = new THREE.Sprite( spriteMaterial );
				sprite.scale.set( textureSize, textureSize, 1 );
				//sceneOrtho.add( sprite );

				updateSpritePosition();
				*/
				/*
				var selection=document.getElementById('selection');
				const modelo=new CSS2DObject(selection);
				console.log("position: "+modelo.position.x);*/

				var base = window.innerWidth;
				var altura = window.innerHeight;
				//console.log("base: "+base);
				//console.log("altura: "+altura);
				var resultadoBase=base/3;
				
				var resultadoBaseEntre2 = base/2;
				var resultadoAltura=altura/3;
				var resultadoAlturaEntre2=resultadoAltura/2;
				var resultadobaseMas5=resultadoAltura+resultadoAlturaEntre2;
				var resultadoAlturaEntre2=altura/2;
				var resultadoEsquinaDerechaBase=resultadoBase*2;
				var resultadoEsquinaDerechaAltura=resultadoAltura*2;
				console.log("resultado de la division base: "+resultadoBase+"  altura: "+resultadoAltura)

				var d1=document.getElementById("d1");
				var d2=document.getElementById("d2");
				var d3=document.getElementById("d3");
				var d4=document.getElementById("d4");

				var d5=document.getElementById("d5");
				var d6=document.getElementById("d6");
				var d7=document.getElementById("d7");
				var d8=document.getElementById("d8");
				/*
				d1.style.width=60+'px';
				d1.style.height=60+'px';*/
				//d1.style.position = "absolute";
				//posicion en x 
				d1.style.left = resultadoBase-30+'px';
				//posicion en y
				d1.style.top = resultadoAltura-30+'px';

				d2.style.left = resultadoEsquinaDerechaBase-30+'px';
				d2.style.top = resultadoAltura-30+'px';

				d3.style.left = resultadoEsquinaDerechaBase-30+'px';
				d3.style.top = resultadoEsquinaDerechaAltura-30+'px';

				d4.style.left = resultadoBase-30+'px';
				d4.style.top = resultadoEsquinaDerechaAltura-30+'px';

				d5.style.left = resultadoBase-30+'px';
				d5.style.top = resultadoAlturaEntre2-30+'px';

				d6.style.left = resultadoBaseEntre2-30+'px';
				d6.style.top = resultadoAltura-30+'px';
				
				d7.style.left = resultadoBaseEntre2-30+'px';
				d7.style.top = resultadoEsquinaDerechaAltura-30+'px';

				d8.style.left = resultadoEsquinaDerechaBase-30+'px';
				d8.style.top = resultadobaseMas5-30+'px';


			}

			const fbx = new FBXLoader();
			fbx.load('3dmodels/aguila-real.fbx',function(personaje){
				personaje.position.set(2,2,2);
				
				//grupoPersonaje.add(personaje);
				//sessionStorage.setItem('personaje',personaje);
				console.log("dame su nombre");
				//le damos un nobre al personaje
				personaje.name="personaje1";
				//acedemos a su nombre
				console.log(personaje.name);
				//mostramos el id de personaje
				console.log(personaje.id);
				// loa añadimos a la escena
				scene.add(personaje);
			});

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}
			/*
			function onPointerMove( event ) {

				//pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				//pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
			}
			*/

			function onPointerMove() {

				//pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				//pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
				var base = window.innerWidth;
				var altura = window.innerHeight;
				//console.log("base: "+base);
				//console.log("altura: "+altura);
				var resultadoBase=base/3;
				
				var resultadoBaseEntre2 = base/2;
				var resultadoAltura=altura/3;
				var resultadoAlturaEntre2=resultadoAltura/2;
				var resultadobaseMas5=resultadoAltura+resultadoAlturaEntre2;
				var resultadoAlturaEntre2=altura/2;
				var resultadoEsquinaDerechaBase=resultadoBase*2;
				var resultadoEsquinaDerechaAltura=resultadoAltura*2;


				//console.log("resultado de la division base: "+resultadoBase+"  altura: "+resultadoAltura)

				pointer.x = resultadoBase;
				pointer.y = resultadoAltura;
				//console.log("punto x: "+punto.x=event.);
				pointer2.x = resultadoEsquinaDerechaBase;
				pointer2.y = resultadoAltura;

				pointer3.x = resultadoEsquinaDerechaBase;
				pointer3.y = resultadoEsquinaDerechaAltura;

				pointer4.x = resultadoBase;
				pointer4.y = resultadoEsquinaDerechaAltura;

				pointer5.x = resultadoBase;
				pointer5.y = resultadoAlturaEntre2;

				pointer6.x = resultadoBaseEntre2;
				pointer6.y = resultadoAltura;
				
				pointer7.x = resultadoBaseEntre2;
				pointer7.y = resultadoEsquinaDerechaAltura;

				pointer8.x = resultadoEsquinaDerechaBase;
				pointer8.y = resultadobaseMas5;

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				//stats.update();
				onPointerMove();
			}

			function render() {

				theta += 0.1;

				camera.position.x = radius * Math.sin( THREE.MathUtils.degToRad( theta ) );
				camera.position.y = radius * Math.sin( THREE.MathUtils.degToRad( theta ) );
				camera.position.z = radius * Math.cos( THREE.MathUtils.degToRad( theta ) );
				camera.lookAt( scene.position );

				camera.updateMatrixWorld();

				// find intersections

				raycaster.setFromCamera( pointer, camera );
				raycaster2.setFromCamera( pointer2, camera );
				raycaster3.setFromCamera( pointer3, camera );
				raycaster4.setFromCamera( pointer4, camera );

				raycaster5.setFromCamera( pointer5, camera );
				raycaster6.setFromCamera( pointer6, camera );
				raycaster7.setFromCamera( pointer7, camera );
				raycaster8.setFromCamera( pointer8, camera );

				const intersects = raycaster.intersectObjects( scene.children, false );
				const intersects2 = raycaster2.intersectObjects( scene.children, false );
				const intersects3 = raycaster3.intersectObjects( scene.children, false );
				const intersects4 = raycaster4.intersectObjects( scene.children, false );

				const intersects5 = raycaster5.intersectObjects( scene.children, false );
				const intersects6 = raycaster6.intersectObjects( scene.children, false );
				const intersects7 = raycaster7.intersectObjects( scene.children, false );
				const intersects8 = raycaster8.intersectObjects( scene.children, false );

				if ( intersects.length > 0 ) {
					if ( INTERSECTED != intersects[ 0 ].object ) {
						const found = arreglo.find(element => element === intersects[ 0 ].object.name);

						if(found===undefined){
							var contenedor=document.getElementById('contenedorObjetos');
							var div=document.createElement('div');
							div.setAttribute("id","dato");
							div.innerText=intersects[ 0 ].object.name;
							contenedor.append(div);
							arreglo.push(intersects[ 0 ].object.name);
							if(arreglo.length===5){
								alert("haz encontrado todos los objetos");
							}
						}
						
						console.log("cambio de color 1");
					}
				}
				if(intersects2.length > 0){
					if(INTERSECTED2 != intersects2[ 0 ].object){
						const found = arreglo.find(element => element === intersects2[ 0 ].object.name);

						if(found===undefined){
							var contenedor=document.getElementById('contenedorObjetos');
							var div=document.createElement('div');
							div.setAttribute("id","dato");
							div.innerText=intersects2[ 0 ].object.name;
							contenedor.append(div);
							arreglo.push(intersects2[ 0 ].object.name);
							if(arreglo.length===5){
								alert("haz encontrado todos los objetos");
							}
						}
						
						console.log("cambio de color 2");
					}
				}
				if(intersects3.length > 0){
					if(INTERSECTED3 != intersects3[ 0 ].object){
						const found = arreglo.find(element => element === intersects3[ 0 ].object.name);

						if(found===undefined){
							var contenedor=document.getElementById('contenedorObjetos');
							var div=document.createElement('div');
							div.setAttribute("id","dato");
							div.innerText=intersects3[ 0 ].object.name;
							contenedor.append(div);
							arreglo.push(intersects3[ 0 ].object.name);
							if(arreglo.length===5){
								alert("haz encontrado todos los objetos");
							}
						}
						
						console.log("cambio de color 3");
					}
				}
				if(intersects4.length > 0){
					if(INTERSECTED4 != intersects4[ 0 ].object){
						const found = arreglo.find(element => element === intersects4[ 0 ].object.name);

						if(found===undefined){
							var contenedor=document.getElementById('contenedorObjetos');
							var div=document.createElement('div');
							div.setAttribute("id","dato");
							div.innerText=intersects4[ 0 ].object.name;
							contenedor.append(div);
							arreglo.push(intersects4[ 0 ].object.name);
							if(arreglo.length===5){
								alert("haz encontrado todos los objetos");
							}
						}
						
						console.log("cambio de color 4");
					}
				}
				if ( intersects5.length > 0 ) {
					if ( INTERSECTED5 != intersects5[ 0 ].object ) {
						const found = arreglo.find(element => element === intersects5[ 0 ].object.name);

						if(found===undefined){
							var contenedor=document.getElementById('contenedorObjetos');
							var div=document.createElement('div');
							div.setAttribute("id","dato");
							div.innerText=intersects5[ 0 ].object.name;
							contenedor.append(div);
							arreglo.push(intersects5[ 0 ].object.name);
							if(arreglo.length===5){
								alert("haz encontrado todos los objetos");
							}
						}
						
						console.log("cambio de color 5");
					}
				}
				if ( intersects6.length > 0 ) {
					if ( INTERSECTED6 != intersects6[ 0 ].object ) {
						const found = arreglo.find(element => element === intersects6[ 0 ].object.name);

						if(found===undefined){
							var contenedor=document.getElementById('contenedorObjetos');
							var div=document.createElement('div');
							div.setAttribute("id","dato");
							div.innerText=intersects6[ 0 ].object.name;
							contenedor.append(div);
							arreglo.push(intersects6[ 0 ].object.name);
							if(arreglo.length===5){
								alert("haz encontrado todos los objetos");
							}
						}
						
						console.log("cambio de color 6");
					}
				}
				if ( intersects7.length > 0 ) {
					if ( INTERSECTED7 != intersects7[ 0 ].object ) {
						const found = arreglo.find(element => element === intersects7[ 0 ].object.name);

						if(found===undefined){
							var contenedor=document.getElementById('contenedorObjetos');
							var div=document.createElement('div');
							div.setAttribute("id","dato");
							div.innerText=intersects7[ 0 ].object.name;
							contenedor.append(div);
							arreglo.push(intersects7[ 0 ].object.name);
							if(arreglo.length===5){
								alert("haz encontrado todos los objetos");
							}
						}

						console.log("cambio de color 7");
					}
				}
				if ( intersects8.length > 0 ) {
					if ( INTERSECTED8 != intersects8[ 0 ].object ) {
						const found = arreglo.find(element => element === intersects8[ 0 ].object.name);

						if(found===undefined){
							var contenedor=document.getElementById('contenedorObjetos');
							var div=document.createElement('div');
							div.setAttribute("id","dato");
							div.innerText=intersects8[ 0 ].object.name;
							contenedor.append(div);
							arreglo.push(intersects8[ 0 ].object.name);
							if(arreglo.length===5){
								alert("haz encontrado todos los objetos");
							}
						}
						console.log("cambio de color 8");
					}
				}
				else {

					if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

					INTERSECTED = null;

				}

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
-->
















<!--creo que ya esto no-->
<!--
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - framebuffer - texture</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		
		<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js"> </script>
		<style>
            body{margin:0;}
			#selection {
				position: fixed;
				display: flex;
				flex-direction: column;
				justify-content: center;
				align-items: center;
				height: 100%;
				width: 100%;
				top: 0;
				z-index: 999;
			}

			#selection > div {
				height: 328px;
				width: 328px;
				border: 1px solid white;
			}
		</style>
	</head>
	<body>

		<div id="selection">
			<div></div>
		</div>

		<script type="module">

			/*
			 // Notice there is no 'import' statement. 'tf' is available on the index-page
			// because of the script tag above.

			// Define a model for linear regression.
			const model = tf.sequential();
			model.add(tf.layers.dense({units: 1, inputShape: [1]}));

			// Prepare the model for training: Specify the loss and the optimizer.
			model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});

			// Generate some synthetic data for training.
			const xs = tf.tensor2d([1, 2, 3, 4], [4, 1]);
			const ys = tf.tensor2d([1, 3, 5, 7], [4, 1]);

			// Train the model using the data.
			model.fit(xs, ys).then(() => {
				// Use the model to do inference on a data point the model hasn't seen before:
				// Open the browser devtools to see the output
				model.predict(tf.tensor2d([5], [1, 1])).print();
			});
			*/
			import * as THREE from './build/three.module.js';

			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import * as GeometryUtils from './jsm/utils/GeometryUtils.js';
            import { FBXLoader } from './jsm/loaders/FBXLoader.js';

			let camera, scene, renderer;
			let line, sprite, texture;

			let cameraOrtho, sceneOrtho;

			let offset = 0;

			const dpr = window.devicePixelRatio;

			const textureSize = 328 * dpr;
			const vector = new THREE.Vector2();
			const color = new THREE.Color();

            let INTERSECTED;
			let theta = 0;
            const raycaster = new THREE.Raycaster();

			init();
			animate();

			function init() {

				//

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera = new THREE.PerspectiveCamera( 70, width / height, 1, 1000 );
				camera.position.z = 20;

				cameraOrtho = new THREE.OrthographicCamera( - width / 2, width / 2, height / 2, - height / 2, 1, 10 );
				cameraOrtho.position.z = 10;

				scene = new THREE.Scene();
				sceneOrtho = new THREE.Scene();

				//

				const points = GeometryUtils.gosper( 8 );

				const geometry = new THREE.BufferGeometry();
				const positionAttribute = new THREE.Float32BufferAttribute( points, 3 );
				geometry.setAttribute( 'position', positionAttribute );
				geometry.center();

				const colorAttribute = new THREE.BufferAttribute( new Float32Array( positionAttribute.array.length ), 3 );
				colorAttribute.setUsage( THREE.DynamicDrawUsage );
				geometry.setAttribute( 'color', colorAttribute );

				const material = new THREE.LineBasicMaterial( { vertexColors: true } );

				line = new THREE.Line( geometry, material );
				line.scale.setScalar( 0.05 );
				scene.add( line );

				//

				const data = new Uint8Array( textureSize * textureSize * 3 );

				texture = new THREE.DataTexture( data, textureSize, textureSize, THREE.RGBFormat );
				texture.minFilter = THREE.NearestFilter;
				texture.magFilter = THREE.NearestFilter;

				//

				const spriteMaterial = new THREE.SpriteMaterial( { map: texture } );
				sprite = new THREE.Sprite( spriteMaterial );
				sprite.scale.set( textureSize, textureSize, 1 );
				sceneOrtho.add( sprite );

				updateSpritePosition();

				//

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.autoClear = false;
				document.body.appendChild( renderer.domElement );

				//

				const selection = document.getElementById( 'selection' );
				const controls = new OrbitControls( camera, selection );
				controls.enablePan = false;

				//
                

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				cameraOrtho.left = - width / 2;
				cameraOrtho.right = width / 2;
				cameraOrtho.top = height / 2;
				cameraOrtho.bottom = - height / 2;
				cameraOrtho.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				updateSpritePosition();

			}

			function updateSpritePosition() {

				const halfWidth = window.innerWidth / 2;
				const halfHeight = window.innerHeight / 2;

				const halfImageWidth = textureSize / 2;
				const halfImageHeight = textureSize / 2;

				sprite.position.set( - halfWidth + halfImageWidth, halfHeight - halfImageHeight, 1 );

			}

			
            document.addEventListener( 'mousemove', onPointerMove );

            function onPointerMove( event ) {

				vector.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				vector.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			}

			function animate() {

				requestAnimationFrame( animate );

				const colorAttribute = line.geometry.getAttribute( 'color' );
				updateColors( colorAttribute );

				// scene rendering

				renderer.clear();
				renderer.render( scene, camera );
                

				// calculate start position for copying data

				vector.x = ( window.innerWidth * dpr / 2 ) - ( textureSize / 2 );
				vector.y = ( window.innerHeight * dpr / 2 ) - ( textureSize / 2 );

				renderer.copyFramebufferToTexture( vector, texture );

				renderer.clearDepth();
				renderer.render( sceneOrtho, cameraOrtho );
                
                //console.log(sceneOrtho.getObjectByName("personaje1"))
                //console.log(sceneOrtho.getObjectById(1,true));
                // find intersections

				raycaster.setFromCamera( vector, camera );

				const intersects = raycaster.intersectObjects( scene.children, false );

				if ( intersects.length > 0 ) {
                    console.log("se entra aqui")
					if ( INTERSECTED != intersects[ 0 ].object ) {

						if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

						INTERSECTED = intersects[ 0 ].object;
						INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						INTERSECTED.material.emissive.setHex( 0xff0000 );

					}

				} else {

					if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

					INTERSECTED = null;

				}

			}
            const fbx = new FBXLoader();
            fbx.load('3dmodels/chibi.fbx',function(personaje){
                personaje.position.set(2,2,2);
                
                //grupoPersonaje.add(personaje);
                //sessionStorage.setItem('personaje',personaje);
                console.log("dame su nombre");
                //le damos un nobre al personaje
                personaje.name="personaje1";
                //acedemos a su nombre
                console.log(personaje.name);
                //mostramos el id de personaje
                console.log(personaje.id);
                // loa añadimos a la escena
                scene.add(personaje);
            });
            //de esta forma podemos acceder a los datos del personaje buscandolo desde la escena
            //var datopersonaje=scene.getObjectByName("personaje1");
            //console.log(datopersonaje)
            const directionalLight = new THREE.DirectionalLight('#ffffff', 4)
directionalLight.castShadow = true
directionalLight.shadow.camera.far = 15
directionalLight.shadow.mapSize.set(1024, 1024)
directionalLight.shadow.normalBias = 0.05
directionalLight.position.set(3.5, 2, - 1.25)
scene.add(directionalLight)


renderer.physicallyCorrectLights = true
renderer.outputEncoding = THREE.sRGBEncoding
renderer.toneMapping = THREE.CineonToneMapping
renderer.toneMappingExposure = 1.75
renderer.shadowMap.enabled = true
renderer.shadowMap.type = THREE.PCFSoftShadowMap
renderer.setClearColor('#211d20')

renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))



			function updateColors( colorAttribute ) {

				const l = colorAttribute.count;
/*
				for ( let i = 0; i < l; i ++ ) {

					const h = ( ( offset + i ) % l ) / l;

					color.setHSL( h, 1, 0.5 );
					colorAttribute.setX( i, color.r );
					colorAttribute.setY( i, color.g );
					colorAttribute.setZ( i, color.b );

				}*/
                

				colorAttribute.needsUpdate = true;

				offset -= 25;

			}

		</script>

	</body>
</html>
-->